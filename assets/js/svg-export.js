/**
 * SVG Export Module for Freight Signs Customizer
 * Generates production-ready SVG files that match client export format
 * 
 * Key Features:
 * - Proper viewBox and dimensions
 * - ClipPath support for complex shapes
 * - Text to path conversion for font consistency
 * - Material/texture embedding
 * - Clean XML structure
 */

(function() {
    'use strict';

    window.FSC_SVGExport = {
        /**
         * Export the current design as a production-ready SVG
         * @param {Object} options - Export options
         * @returns {Promise<string>} SVG content as string
         */
        exportDesign: async function(options = {}) {
            console.log('üé® Starting SVG export...', options);
            
            const defaults = {
                width: 600,           // Default width in pixels
                height: 450,          // Default height in pixels
                dpi: 300,             // For print: 300 DPI
                includeBackground: true,
                convertTextToPaths: false, // Set true for production
                embedFonts: true,
                format: 'svg',        // 'svg' or 'pdf' (future)
                colorMode: 'rgb'      // 'rgb' or 'cmyk' (future)
            };
            
            const config = { ...defaults, ...options };
            
            try {
                // Get the preview area
                const previewArea = document.querySelector('.apd-template-preview, .fsc-preview-content');
                if (!previewArea) {
                    throw new Error('Preview area not found');
                }
                
                // Get logo and text elements
                const logoContainer = previewArea.querySelector('.fsc-logo-container, .apd-logo-box');
                const textContainer = previewArea.querySelector('.fsc-text-container, .apd-text-layer');
                
                // Start building the SVG
                const svgContent = await this._buildProductionSVG({
                    logoContainer,
                    textContainer,
                    config
                });
                
                console.log('‚úÖ SVG export complete');
                return svgContent;
                
            } catch (error) {
                console.error('‚ùå SVG export failed:', error);
                throw error;
            }
        },
        
        /**
         * Build production-ready SVG with proper structure
         */
        _buildProductionSVG: async function({ logoContainer, textContainer, config }) {
            const { width, height, dpi } = config;
            
            // Calculate viewBox for high resolution
            const viewBoxWidth = width * (dpi / 96); // 96 is screen DPI
            const viewBoxHeight = height * (dpi / 96);
            
            // Start SVG with proper XML declaration
            let svg = `<?xml version="1.0" encoding="UTF-8"?>\n`;
            svg += `<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n`;
            svg += `<!-- Generated by Freight Signs Customizer -->\n`;
            svg += `<svg xmlns="http://www.w3.org/2000/svg"`;
            svg += ` xmlns:xlink="http://www.w3.org/1999/xlink"`;
            svg += ` width="${width}px" height="${height}px"`;
            svg += ` viewBox="0 0 ${viewBoxWidth} ${viewBoxHeight}"`;
            svg += ` version="1.1"`;
            svg += ` xml:space="preserve"`;
            svg += ` style="shape-rendering:geometricPrecision; text-rendering:geometricPrecision; image-rendering:optimizeQuality; fill-rule:evenodd; clip-rule:evenodd">\n`;
            
            // Add defs section for patterns, gradients, clipPaths
            svg += `  <defs>\n`;
            
            // Add material patterns if available
            const materialPatterns = await this._generateMaterialPatterns();
            if (materialPatterns) {
                svg += materialPatterns;
            }
            
            // Add fonts if embedding
            if (config.embedFonts) {
                const fontDefs = await this._generateFontDefs();
                if (fontDefs) {
                    svg += fontDefs;
                }
            }
            
            svg += `  </defs>\n`;
            
            // Add main group
            svg += `  <g id="design-layer">\n`;
            
            // Add background if requested
            if (config.includeBackground) {
                svg += `    <rect width="${viewBoxWidth}" height="${viewBoxHeight}" fill="#FFFFFF"/>\n`;
            }
            
            // Add logo layer
            if (logoContainer) {
                const logoSVG = await this._processLogoLayer(logoContainer, config);
                svg += logoSVG;
            }
            
            // Add text layer
            if (textContainer) {
                const textSVG = await this._processTextLayer(textContainer, config);
                svg += textSVG;
            }
            
            svg += `  </g>\n`;
            svg += `</svg>`;
            
            return svg;
        },
        
        /**
         * Process logo layer with materials and colors
         */
        _processLogoLayer: async function(logoContainer, config) {
            let logoSVG = '';
            
            // Find the logo SVG element
            const logoElement = logoContainer.querySelector('svg');
            if (!logoElement) {
                return logoSVG;
            }
            
            logoSVG += `    <!-- Logo Layer -->\n`;
            logoSVG += `    <g id="logo-layer">\n`;
            
            // Clone and process the logo SVG
            const clonedLogo = logoElement.cloneNode(true);
            
            // Get current material and color
            const currentMaterial = window.FSC?.currentMaterial || '';
            const currentColor = window.FSC?.currentColor || '#000000';
            const colorValue = this._getColorValue(currentColor);
            
            // Process all paths in the logo
            const paths = clonedLogo.querySelectorAll('path, rect, circle, ellipse, polygon, polyline');
            paths.forEach((path, index) => {
                // Set fill and stroke based on material and color
                if (currentMaterial && currentMaterial !== 'None') {
                    // Use material pattern
                    path.setAttribute('fill', `url(#material-${currentMaterial})`);
                    path.setAttribute('stroke', colorValue);
                    path.setAttribute('stroke-width', '2');
                } else {
                    // Use solid color
                    path.setAttribute('fill', colorValue);
                }
            });
            
            // Get the inner HTML of the processed logo
            logoSVG += `      ${clonedLogo.innerHTML}\n`;
            
            logoSVG += `    </g>\n`;
            
            return logoSVG;
        },
        
        /**
         * Process text layer with proper positioning
         */
        _processTextLayer: async function(textContainer, config) {
            let textSVG = '';
            
            textSVG += `    <!-- Text Layer -->\n`;
            textSVG += `    <g id="text-layer">\n`;
            
            // Get all text elements
            const textElements = textContainer.querySelectorAll('.fsc-text-item, [class*="text"]');
            
            textElements.forEach((textEl, index) => {
                const text = textEl.textContent || textEl.innerText;
                if (!text) return;
                
                // Get computed styles
                const computedStyle = window.getComputedStyle(textEl);
                const fontSize = parseInt(computedStyle.fontSize) || 28;
                const fontFamily = computedStyle.fontFamily || 'Arial';
                const fontWeight = computedStyle.fontWeight || 'normal';
                const color = computedStyle.color || '#000000';
                const textAlign = computedStyle.textAlign || 'center';
                
                // Get position
                const rect = textEl.getBoundingClientRect();
                const containerRect = textContainer.getBoundingClientRect();
                const x = rect.left - containerRect.left + (rect.width / 2);
                const y = rect.top - containerRect.top + fontSize;
                
                if (config.convertTextToPaths) {
                    // TODO: Convert text to paths for better compatibility
                    textSVG += `      <!-- Text converted to path -->\n`;
                } else {
                    // Keep as text element
                    textSVG += `      <text x="${x}" y="${y}"`;
                    textSVG += ` font-family="${fontFamily}"`;
                    textSVG += ` font-size="${fontSize}"`;
                    textSVG += ` font-weight="${fontWeight}"`;
                    textSVG += ` fill="${color}"`;
                    textSVG += ` text-anchor="middle"`;
                    textSVG += `>${this._escapeXML(text)}</text>\n`;
                }
            });
            
            textSVG += `    </g>\n`;
            
            return textSVG;
        },
        
        /**
         * Generate material pattern definitions
         */
        _generateMaterialPatterns: async function() {
            let patterns = '';
            
            // Get available materials from FSC
            const materials = window.FSC?.materialsMap || {};
            
            for (const [materialName, materialData] of Object.entries(materials)) {
                if (materialName === 'None') continue;
                
                const textureUrl = materialData?.image || materialData?.texture || '';
                if (!textureUrl) continue;
                
                patterns += `    <pattern id="material-${materialName}" patternUnits="userSpaceOnUse" width="100" height="100">\n`;
                patterns += `      <image xlink:href="${textureUrl}" width="100" height="100"/>\n`;
                patterns += `    </pattern>\n`;
            }
            
            return patterns;
        },
        
        /**
         * Generate font definitions for embedding
         */
        _generateFontDefs: async function() {
            let fontDefs = '';
            
            // TODO: Implement font embedding using @font-face or base64
            // This requires converting web fonts to SVG fonts or embedding as WOFF2
            
            return fontDefs;
        },
        
        /**
         * Get color value from color name or hex
         */
        _getColorValue: function(color) {
            if (!color) return '#000000';
            
            // If it's already a hex color, return it
            if (color.startsWith('#')) return color;
            
            // Try to get from FSC color map
            const colorMap = window.FSC?.colorMap || {};
            return colorMap[color] || '#000000';
        },
        
        /**
         * Escape XML special characters
         */
        _escapeXML: function(str) {
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        },
        
        /**
         * Download the SVG file
         */
        downloadSVG: async function(filename = 'freight-sign-design.svg') {
            try {
                const svgContent = await this.exportDesign({
                    dpi: 300,
                    convertTextToPaths: false,
                    embedFonts: true
                });
                
                // Create blob and download
                const blob = new Blob([svgContent], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Clean up
                setTimeout(() => URL.revokeObjectURL(url), 100);
                
                console.log('‚úÖ SVG downloaded:', filename);
                return true;
                
            } catch (error) {
                console.error('‚ùå SVG download failed:', error);
                return false;
            }
        },
        
        /**
         * Get SVG as data URL for preview/storage
         */
        getSVGDataURL: async function() {
            try {
                const svgContent = await this.exportDesign({
                    dpi: 150, // Lower DPI for preview
                    convertTextToPaths: false
                });
                
                // Convert to data URL
                const dataUrl = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgContent)));
                return dataUrl;
                
            } catch (error) {
                console.error('‚ùå Failed to generate SVG data URL:', error);
                return null;
            }
        }
    };
    
    console.log('‚úÖ SVG Export module loaded');
    
})();
